{
  parserClass="nl.petertillema.tibasic.parser.TIBasicParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="TIBasic"
  psiImplClassSuffix="Impl"
  psiPackage="nl.petertillema.tibasic.psi"
  psiImplPackage="nl.petertillema.tibasic.psi.impl"
  psiImplUtilClass="nl.petertillema.tibasic.psi.impl.TIBasicPsiImplUtil"

  elementTypeHolderClass="nl.petertillema.tibasic.psi.TIBasicTypes"
  elementTypeClass="nl.petertillema.tibasic.psi.TIBasicElementType"
  tokenTypeClass="nl.petertillema.tibasic.psi.TIBasicTokenType"

  extends(".*expr")=expr
  extends(".*_statement")=statement
  tokens=[
    COMMENT = "regexp://[^\r\n]*"
  ]
}

tibasicFile ::= NEWLINE* [statements] NEWLINE*
private statements ::= statement (NEWLINE+ statement)*
statement ::= compound_statement | simple_statement

private meta list ::= <<p>> (COMMA <<p>>)*

private NEWLINE ::= CRLF | COLON
private statement_recover ::= !NEWLINE

private end_block_ ::= NEWLINE+ (!END (statement NEWLINE*))*
private then_block_ ::= NEWLINE+ (!ELSE !END (statement NEWLINE*))*

private simple_statement ::= small_statement { recoverWhile=statement_recover }
private small_statement ::= delvar_statement | goto_statement | lbl_statement | command_statement | prgm_statement | assignment_statement | expr_statement
private compound_statement ::= if_statement | while_statement | repeat_statement | for_statement

private unused_ ::= TOKEN

//////////////////////////////////////// BASIC EXPRESSION ////////////////////////////////////////
expr ::= conversion_group
  | or_group
  | and_group
  | comparison_group
  | addition_group
  | multiplication_group
  | combinations_group
  | negation_group
  | exponential_group
  | modifiers_group
  | primary_group

// Private rules to define operators with the same priority
private conversion_group ::= dms_expr | dec_expr | frac_expr
private or_group ::= or_expr | xor_expr
private and_group ::= and_expr
private comparison_group ::= eq_expr | ne_expr | gt_expr | ge_expr | lt_expr | le_expr
private addition_group ::= plus_expr | minus_expr
private multiplication_group ::= mul_expr | div_expr | implied_mul_expr
private combinations_group ::= npr_expr | ncr_expr
private negation_group ::= negation_expr
private exponential_group ::= pow_expr | xroot_expr
private modifiers_group ::= radian_expr | degree_expr | inverse_expr | pow2_expr | transpose_expr | pow3_expr
private primary_group ::= literal_expr | func_expr | paren_expr

// Public rules for each expression
// Precedence 10
dms_expr ::= expr "►DMS"
dec_expr ::= expr "►Dec"
frac_expr ::= expr "►Frac"
// Precedence 9
or_expr ::= expr OR expr
xor_expr ::= expr XOR expr
// Precedence 8
and_expr ::= expr AND expr
// Precedence 7
eq_expr ::= expr EQ expr
ne_expr ::= expr NE expr
gt_expr ::= expr GT expr
ge_expr ::= expr GE expr
lt_expr ::= expr LT expr
le_expr ::= expr LE expr
// Precedence 6
plus_expr ::= expr PLUS expr
minus_expr ::= expr MINUS expr
// Precedence 5
mul_expr ::= expr TIMES expr
div_expr ::= expr DIVIDE expr
implied_mul_expr ::= implied_mul_arg implied_mul_arg+
private implied_mul_arg ::= NUMBER | MATH_VARIABLE | EXPR_FUNCTIONS_NO_ARGS | ANS_VARIABLE | LIST_VARIABLE | custom_list_with_l | EQUATION_VARIABLE | SIMPLE_VARIABLE | COLOR_VARIABLE | paren_expr | func_expr
// Precedence 4
npr_expr ::= expr NPR expr
ncr_expr ::= expr NCR expr
// Precedence 3.5
negation_expr ::= NEG expr
// Precedence 3
pow_expr ::= expr POW expr
xroot_expr ::= expr "×√" expr
// Precedence 2
radian_expr ::= expr TO_RADIAN
degree_expr ::= expr TO_DEGREE
inverse_expr ::= expr INVERSE
pow2_expr ::= expr POW2
transpose_expr ::= expr TRANSPOSE
pow3_expr ::= expr POW3
// Precedence 1
paren_expr ::= LPAREN expr [RPAREN]
func_expr ::= EXPR_FUNCTIONS_WITH_ARGS LPAREN <<list expr>> [RPAREN] { pin=1 }

// Base literal
literal_expr ::= list_index | matrix_index | EXPR_FUNCTIONS_NO_ARGS | ANS_VARIABLE | LIST_VARIABLE | custom_list_with_l | EQUATION_VARIABLE | STRING_VARIABLE | SIMPLE_VARIABLE | MATRIX_VARIABLE | COLOR_VARIABLE | MATH_VARIABLE | NUMBER | STRING | anonymous_list | anonymous_matrix
{
    methods=[getReferences]
}
list_index ::= (LIST_VARIABLE | custom_list_with_l) LPAREN expr [RPAREN] { pin=2 }
matrix_index ::= MATRIX_VARIABLE LPAREN expr COMMA expr [RPAREN] { pin=2 }
anonymous_list ::= LCURLY <<list expr>> [RCURLY] { pin=1 }
anonymous_matrix ::= LBRACKET <<list anonymous_matrix_row>> [RBRACKET] { pin=1 }
anonymous_matrix_row ::= LBRACKET <<list expr>> [RBRACKET] { pin=1 }
//////////////////////////////////////// BASIC EXPRESSION ////////////////////////////////////////

/////////////////////////////////////// SIMPLE STATEMENTS ////////////////////////////////////////
expr_statement ::= expr
assignment_statement ::= expr STO assignment_target { pin=2 }
assignment_target ::= assignment_target_matrix_index | assignment_target_list_index | assignment_target_variable | assignment_target_dim
{
    mixin="nl.petertillema.tibasic.psi.impl.TIBasicNamedElementImpl"
    implements="nl.petertillema.tibasic.psi.TIBasicNamedElement"
    methods=[getName setName getNameIdentifier]
}
private assignment_target_matrix_index ::= MATRIX_VARIABLE LPAREN expr COMMA expr [RPAREN] { pin=2 }
private assignment_target_list_index ::= (LIST_VARIABLE | custom_list_with_l) LPAREN expr [RPAREN] { pin=2 }
private assignment_target_variable ::= LIST_VARIABLE | custom_list_with_l | custom_list_name | EQUATION_VARIABLE | STRING_VARIABLE | SIMPLE_VARIABLE | MATRIX_VARIABLE | WINDOW_TOKENS
private assignment_target_dim ::= "dim(" (LIST_VARIABLE | custom_list_with_l | MATRIX_VARIABLE) [RPAREN] { pin=1 }

private custom_list_with_l ::= CUSTOM_LIST_L custom_list_name
private custom_list_name ::= SIMPLE_VARIABLE [custom_list_char] [custom_list_char] [custom_list_char] [custom_list_char]
private custom_list_char ::= SIMPLE_VARIABLE | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

delvar_statement ::= delvar_variable+ [statement]
private delvar_variable ::= "DelVar" (LIST_VARIABLE | custom_list_with_l | EQUATION_VARIABLE | STRING_VARIABLE | SIMPLE_VARIABLE | MATRIX_VARIABLE | PICTURE_VARIABLE) { pin=1 }

goto_statement ::= GOTO goto_name { pin=1 }
goto_name ::= (SIMPLE_VARIABLE | NUMBER) [SIMPLE_VARIABLE | NUMBER]
{
    methods=[getReferences]
}
lbl_statement ::= LBL lbl_name { pin=1 }
lbl_name ::= (SIMPLE_VARIABLE | NUMBER) [SIMPLE_VARIABLE | NUMBER]
{
    mixin="nl.petertillema.tibasic.psi.impl.TIBasicNamedElementImpl"
    implements="nl.petertillema.tibasic.psi.TIBasicNamedElement"
    methods=[getName setName getNameIdentifier]
}

prgm_statement ::= PRGM_CALL

command_statement ::= simple_command | arguments_command
private simple_command ::= COMMAND_NO_PARENS [<<list expr>>] { pin=1 }
private arguments_command ::= COMMAND_WITH_PARENS LPAREN <<list expr>> [RPAREN] { pin=1 }

/////////////////////////////////////// SIMPLE STATEMENTS ////////////////////////////////////////

////////////////////////////////////// COMPOUND STATEMENTS ///////////////////////////////////////
if_statement ::= IF expr NEWLINE if_body
private if_body ::= (then_block [else_block | END]) | statement
then_block ::= THEN then_block_
else_block ::= ELSE end_block_ [END]

while_statement ::= WHILE expr end_block_ [END]

repeat_statement ::= REPEAT expr end_block_ [END]

for_statement ::= for_initializer end_block_ [END]
for_initializer ::= FOR LPAREN for_identifier COMMA expr COMMA expr [COMMA expr] [RPAREN]
for_identifier ::= SIMPLE_VARIABLE
{
    mixin="nl.petertillema.tibasic.psi.impl.TIBasicNamedElementImpl"
    implements="nl.petertillema.tibasic.psi.TIBasicNamedElement"
    methods=[getName setName getNameIdentifier]
}
////////////////////////////////////// COMPOUND STATEMENTS ///////////////////////////////////////
