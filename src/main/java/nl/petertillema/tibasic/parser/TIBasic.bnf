{
  parserClass="nl.petertillema.tibasic.parser.TIBasicParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="TIBasic"
  psiImplClassSuffix="Impl"
  psiPackage="nl.petertillema.tibasic.psi"
  psiImplPackage="nl.petertillema.tibasic.psi.impl"
  psiImplUtilClass="nl.petertillema.tibasic.psi.impl.TIBasicPsiImplUtil"

  elementTypeHolderClass="nl.petertillema.tibasic.psi.TIBasicTypes"
  elementTypeClass="nl.petertillema.tibasic.psi.TIBasicElementType"
  tokenTypeClass="nl.petertillema.tibasic.psi.TIBasicTokenType"

  extends(".*expr")=expr
  tokens=[
    COMMENT = "regexp://[^\r\n]*"
  ]
}

tibasicFile ::= NEWLINE* [statements] NEWLINE*
private statements ::= statement (NEWLINE+ statement)*
statement ::= compound_statement | simple_statement

private NEWLINE ::= CRLF | COLON
private statement_recover ::= !NEWLINE

end_block ::= NEWLINE+ (!"End" (statement NEWLINE*))*
then_block ::= NEWLINE+ (!"Else" !"End" (statement NEWLINE*))*

private simple_statement ::= small_statement { recoverWhile=statement_recover }
private small_statement ::= delvar_command | goto_statement | lbl_statement | command_statement | assignment_statement | expr
private compound_statement ::= if_statement | while_statement | repeat_statement | for_statement

private unused_ ::= TOKEN

//////////////////////////////////////// BASIC EXPRESSION ////////////////////////////////////////
expr ::= conversion_group
  | or_group
  | and_group
  | comparison_group
  | addition_group
  | multiplication_group
  | combinations_group
  | negation_group
  | exponential_group
  | modifiers_group
  | primary_group

// Private rules to define operators with the same priority
private conversion_group ::= dms_expr | dec_expr | frac_expr
private or_group ::= or_expr | xor_expr
private and_group ::= and_expr
private comparison_group ::= eq_expr | ne_expr | gt_expr | ge_expr | lt_expr | le_expr
private addition_group ::= plus_expr | minus_expr
private multiplication_group ::= mul_expr | div_expr | implied_mul_expr
private combinations_group ::= npr_expr | ncr_expr
private negation_group ::= negation_expr
private exponential_group ::= pow_expr | xroot_expr
private modifiers_group ::= radian_expr | degree_expr | inverse_expr | pow2_expr | transpose_expr | pow3_expr
private primary_group ::= literal_expr | func_expr | paren_expr

// Public rules for each expression
// Precedence 10
dms_expr ::= expr "►DMS"
dec_expr ::= expr "►Dec"
frac_expr ::= expr "►Frac"
// Precedence 9
or_expr ::= expr OR expr
xor_expr ::= expr XOR expr
// Precedence 8
and_expr ::= expr AND expr
// Precedence 7
eq_expr ::= expr EQ expr
ne_expr ::= expr NE expr
gt_expr ::= expr GT expr
ge_expr ::= expr GE expr
lt_expr ::= expr LT expr
le_expr ::= expr LE expr
// Precedence 6
plus_expr ::= expr PLUS expr
minus_expr ::= expr MINUS expr
// Precedence 5
mul_expr ::= expr TIMES expr
div_expr ::= expr DIVIDE expr
implied_mul_expr ::= implied_mul_arg implied_mul_arg+
private implied_mul_arg ::= NUMBER | EXPR_FUNCTIONS_NO_ARGS | ANS_VARIABLE | LIST_VARIABLE | EQUATION_VARIABLE_1 | EQUATION_VARIABLE_2 | EQUATION_VARIABLE_3 | EQUATION_VARIABLE_4 | SIMPLE_VARIABLE | COLOR_VARIABLE | paren_expr | func_expr
// Precedence 4
npr_expr ::= expr NPR expr
ncr_expr ::= expr NCR expr
// Precedence 3.5
negation_expr ::= NEG expr
// Precedence 3
pow_expr ::= expr POW expr
xroot_expr ::= expr "×√" expr
// Precedence 2
radian_expr ::= expr TO_RADIAN
degree_expr ::= expr TO_DEGREE
inverse_expr ::= expr INVERSE
pow2_expr ::= expr POW2
transpose_expr ::= expr TRANSPOSE
pow3_expr ::= expr POW3
// Precedence 1
paren_expr ::= LPAREN expr [RPAREN]
func_expr ::= EXPR_FUNCTIONS_WITH_ARGS LPAREN expr (COMMA expr)* [RPAREN] { pin=1 }

// Base literal
literal_expr ::= list_index | matrix_index | EXPR_FUNCTIONS_NO_ARGS | ANS_VARIABLE | LIST_VARIABLE | EQUATION_VARIABLE_1 | EQUATION_VARIABLE_2 | EQUATION_VARIABLE_3 | EQUATION_VARIABLE_4 | STRING_VARIABLE | SIMPLE_VARIABLE | MATRIX_VARIABLE | COLOR_VARIABLE | MATH_VARIABLE | NUMBER | STRING | anonymous_list | anonymous_matrix
{
    methods=[getReferences]
}
list_index ::= LIST_VARIABLE LPAREN expr [RPAREN] { pin=2 }
matrix_index ::= MATRIX_VARIABLE LPAREN expr COMMA expr [RPAREN] { pin=2 }
anonymous_list ::= LCURLY expr (COMMA expr)* [RCURLY] { pin=1 }
anonymous_matrix ::= LBRACKET anonymous_matrix_row (COMMA anonymous_matrix_row)* [RBRACKET] { pin=1 }
anonymous_matrix_row ::= LBRACKET expr (COMMA expr)* [RBRACKET] { pin=1 }
//////////////////////////////////////// BASIC EXPRESSION ////////////////////////////////////////

/////////////////////////////////////// SIMPLE STATEMENTS ////////////////////////////////////////
assignment_statement ::= expr STO assignment_target { pin=2 }
assignment_target ::= assignment_target_matrix_index | assignment_target_list_index | assignment_target_variable | assignment_target_dim
{
    mixin="nl.petertillema.tibasic.psi.impl.TIBasicNamedElementImpl"
    implements="nl.petertillema.tibasic.psi.TIBasicNamedElement"
    methods=[getName setName getNameIdentifier]
}
private assignment_target_variable ::= LIST_VARIABLE | LIST_VARIABLE_NAME | EQUATION_VARIABLE_1 | EQUATION_VARIABLE_2 | EQUATION_VARIABLE_3 | EQUATION_VARIABLE_4 | STRING_VARIABLE | SIMPLE_VARIABLE | MATRIX_VARIABLE | WINDOW_TOKENS
private assignment_target_matrix_index ::= MATRIX_VARIABLE LPAREN expr COMMA expr [RPAREN] { pin=1 }
private assignment_target_list_index ::= LIST_VARIABLE LPAREN expr [RPAREN] { pin=1 }
private assignment_target_dim ::= "dim(" (LIST_VARIABLE | MATRIX_VARIABLE) [RPAREN] { pin=1 }

delvar_command ::= ("DelVar " (LIST_VARIABLE | EQUATION_VARIABLE_1 | EQUATION_VARIABLE_2 | EQUATION_VARIABLE_3 | EQUATION_VARIABLE_4 | STRING_VARIABLE | SIMPLE_VARIABLE | MATRIX_VARIABLE))+ [statement] { pin=1 }

goto_statement ::= GOTO goto_name { pin=1 }
goto_name ::= (SIMPLE_VARIABLE | NUMBER) [SIMPLE_VARIABLE | NUMBER]
{
    methods=[getReferences]
}
lbl_statement ::= LBL lbl_name { pin=1 }
lbl_name ::= (SIMPLE_VARIABLE | NUMBER) [SIMPLE_VARIABLE | NUMBER]
{
    mixin="nl.petertillema.tibasic.psi.impl.TIBasicNamedElementImpl"
    implements="nl.petertillema.tibasic.psi.TIBasicNamedElement"
    methods=[getName setName getNameIdentifier]
}

command_statement ::= simple_command | arguments_command
private simple_command ::= COMMAND_NO_PARENS [(expr (COMMA expr)*)] { pin=1 }
private arguments_command ::= COMMAND_WITH_PARENS LPAREN expr (COMMA expr)* [RPAREN] { pin=1 }

/////////////////////////////////////// SIMPLE STATEMENTS ////////////////////////////////////////

////////////////////////////////////// COMPOUND STATEMENTS ///////////////////////////////////////
if_statement ::= IF expr NEWLINE (then_statement | statement)
then_statement ::= THEN then_block [else_statement | END]
else_statement ::= ELSE end_block [END]

while_statement ::= WHILE expr end_block [END]

repeat_statement ::= REPEAT expr end_block [END]

for_statement ::= FOR LPAREN for_identifier COMMA expr COMMA expr [COMMA expr] [RPAREN] end_block [END]
for_identifier ::= SIMPLE_VARIABLE
{
    mixin="nl.petertillema.tibasic.psi.impl.TIBasicNamedElementImpl"
    implements="nl.petertillema.tibasic.psi.TIBasicNamedElement"
    methods=[getName setName getNameIdentifier]
}
////////////////////////////////////// COMPOUND STATEMENTS ///////////////////////////////////////
