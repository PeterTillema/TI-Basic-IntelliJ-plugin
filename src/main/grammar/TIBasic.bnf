{
  parserClass="nl.petertillema.tibasic.parser.TIBasicParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="TIBasic"
  psiImplClassSuffix="Impl"
  psiPackage="nl.petertillema.tibasic.psi"
  psiImplPackage="nl.petertillema.tibasic.psi.impl"
  psiImplUtilClass="nl.petertillema.tibasic.psi.impl.TIBasicPsiImplUtil"

  elementTypeHolderClass="nl.petertillema.tibasic.psi.TIBasicTypes"
  elementTypeClass="nl.petertillema.tibasic.psi.TIBasicElementType"
  tokenTypeClass="nl.petertillema.tibasic.psi.TIBasicTokenType"

  extends(".*expr")=expr
  extends(".*_statement")=statement
  tokens=[
    COMMENT = "regexp://[^\r\n]*"
    TOKEN = "regexp:(.+)"
  ]
}

tibasicFile ::= NEWLINE* [statements] NEWLINE*
private statements ::= statement_internal (NEWLINE+ statement_internal)*
private statement_internal ::= compound_statement | simple_statement
fake statement ::=

private meta list ::= <<p>> (COMMA <<p>>)*
private optional_rparen ::= [RPAREN]
private optional_end ::= [END]

private NEWLINE ::= CRLF | COLON
private statement_recover ::= !NEWLINE

private end_block_ ::= NEWLINE+ (!END (statement_internal NEWLINE*))*
private then_block_ ::= NEWLINE+ (!ELSE !END (statement_internal NEWLINE*))*

private simple_statement ::= small_statement { recoverWhile=statement_recover }
private small_statement ::= delvar_statement |
    goto_statement |
    lbl_statement |
    menu_statement |
    plot_statement |
    disp_statement |
    command_statement |
    asm_statement |
    prgm_statement |
    expr_statement
private compound_statement ::= is_ds_statement |
    if_statement |
    while_statement |
    repeat_statement |
    for_statement

//////////////////////////////////////// BASIC EXPRESSION ////////////////////////////////////////
expr ::= or_group
  | and_group
  | comparison_group
  | addition_group
  | multiplication_group
  | combinations_group
  | negation_group
  | exponential_group
  | modifiers_group
  | primary_group

// Private rules to define operators with the same priority
private or_group ::= or_expr | xor_expr
private and_group ::= and_expr
private comparison_group ::= eq_expr | ne_expr | gt_expr | ge_expr | lt_expr | le_expr
private addition_group ::= plus_expr | minus_expr
private multiplication_group ::= mul_expr | div_expr | implied_mul_expr
private combinations_group ::= npr_expr | ncr_expr
private negation_group ::= negation_expr
private exponential_group ::= pow_expr | xroot_expr
private modifiers_group ::= radian_expr | degree_expr | inverse_expr | pow2_expr | transpose_expr | pow3_expr | factorial_expr
private primary_group ::= literal_expr | func_expr | func_optional_expr | paren_expr

// Public rules for each expression
// Precedence 9
or_expr ::= expr OR expr
xor_expr ::= expr XOR expr
// Precedence 8
and_expr ::= expr AND expr
// Precedence 7
eq_expr ::= expr EQ expr
ne_expr ::= expr NE expr
gt_expr ::= expr GT expr
ge_expr ::= expr GE expr
lt_expr ::= expr LT expr
le_expr ::= expr LE expr
// Precedence 6
plus_expr ::= expr PLUS expr
minus_expr ::= expr MINUS expr
// Precedence 5
mul_expr ::= expr TIMES expr
div_expr ::= expr DIVIDE expr
implied_mul_expr ::= expr (modifiers_group | primary_group)
// Precedence 4
npr_expr ::= expr NPR expr
ncr_expr ::= expr NCR expr
// Precedence 3.5
negation_expr ::= NEG expr
// Precedence 3
pow_expr ::= expr POW expr { rightAssociative=true }
xroot_expr ::= expr XROOT expr
// Precedence 2
radian_expr ::= expr TO_RADIAN
degree_expr ::= expr TO_DEGREE
inverse_expr ::= expr INVERSE
pow2_expr ::= expr POW2
transpose_expr ::= expr TRANSPOSE
pow3_expr ::= expr POW3
factorial_expr ::= expr FACTORIAL
// Precedence 1
paren_expr ::= LPAREN expr optional_rparen
func_expr ::= (EXPR_FUNCTIONS_WITH_ARGS | DIM) LPAREN <<list expr>> optional_rparen { pin=1 }
func_optional_expr ::= EXPR_FUNCTIONS_OPTIONAL_ARGS [LPAREN <<list expr>> optional_rparen] { pin=1 }

// Base literal
literal_expr ::= list_index | matrix_index | EXPR_FUNCTIONS_NO_ARGS | ANS_VARIABLE | LIST_VARIABLE | custom_list_with_l | EQUATION_VARIABLE | STRING_VARIABLE | SIMPLE_VARIABLE | WINDOW_VARIABLE | MATRIX_VARIABLE | COLOR_VARIABLE | MATH_VARIABLE | NUMBER | STRING | anonymous_list | anonymous_matrix
{
    methods=[getReferences]
}
list_index ::= (LIST_VARIABLE | ANS_VARIABLE | custom_list_with_l) LPAREN expr optional_rparen { pin=2 }
matrix_index ::= (MATRIX_VARIABLE | ANS_VARIABLE) LPAREN expr COMMA expr optional_rparen { pin=2 }
anonymous_list ::= LCURLY <<list expr>> [RCURLY] { pin=1 }
anonymous_matrix ::= LBRACKET <<list anonymous_matrix_row>> [RBRACKET] { pin=1 }
anonymous_matrix_row ::= LBRACKET <<list expr>> [RBRACKET] { pin=1 }
//////////////////////////////////////// BASIC EXPRESSION ////////////////////////////////////////

/////////////////////////////////////// SIMPLE STATEMENTS ////////////////////////////////////////
expr_statement ::= expr [EXPR_MODIFIER | assignment_statement]
left assignment_statement ::= STO assignment_target { pin=1 }
assignment_target ::= assignment_target_matrix_index | assignment_target_list_index | assignment_target_variable | assignment_target_dim
{
    mixin="nl.petertillema.tibasic.psi.impl.TIBasicNamedElementImpl"
    implements="nl.petertillema.tibasic.psi.TIBasicNamedElement"
    methods=[getName setName getNameIdentifier]
}
private assignment_target_matrix_index ::= MATRIX_VARIABLE LPAREN expr COMMA expr optional_rparen { pin=2 }
private assignment_target_list_index ::= (LIST_VARIABLE | custom_list_with_l) LPAREN expr optional_rparen { pin=2 }
private assignment_target_variable ::= LIST_VARIABLE | custom_list_with_l | custom_list_name | EQUATION_VARIABLE | STRING_VARIABLE | SIMPLE_VARIABLE | MATRIX_VARIABLE | WINDOW_VARIABLE
private assignment_target_dim ::= DIM LPAREN (LIST_VARIABLE | custom_list_with_l | MATRIX_VARIABLE) optional_rparen { pin=1 }

private custom_list_with_l ::= CUSTOM_LIST_L custom_list_name
private custom_list_name ::= SIMPLE_VARIABLE [custom_list_char] [custom_list_char] [custom_list_char] [custom_list_char]
private custom_list_char ::= SIMPLE_VARIABLE | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

delvar_statement ::= delvar_variable+ [statement_internal]
private delvar_variable ::= DELVAR (LIST_VARIABLE | custom_list_with_l | EQUATION_VARIABLE | STRING_VARIABLE | SIMPLE_VARIABLE | MATRIX_VARIABLE | PICTURE_VARIABLE) { pin=1 }

goto_statement ::= GOTO goto_name { pin=1 }
goto_name ::= (SIMPLE_VARIABLE | NUMBER) [SIMPLE_VARIABLE | NUMBER] { methods=[getReferences] }
lbl_statement ::= LBL lbl_name { pin=1 }
lbl_name ::= (SIMPLE_VARIABLE | NUMBER) [SIMPLE_VARIABLE | NUMBER]
{
    mixin="nl.petertillema.tibasic.psi.impl.TIBasicNamedElementImpl"
    implements="nl.petertillema.tibasic.psi.TIBasicNamedElement"
    methods=[getName setName getNameIdentifier]
}

asm_statement ::= ASM LPAREN PRGM_CALL optional_rparen { pin=1 }

prgm_statement ::= PRGM_CALL

disp_statement ::= DISP [<<list disp_item>>]
private disp_item ::= expr [EXPR_MODIFIER]

menu_statement ::= "Menu" LPAREN expr COMMA <<list menu_option>> optional_rparen { pin=1 }
menu_option ::= expr COMMA goto_name { pin=1 }

plot_statement ::= PLOT_COMMAND LPAREN PLOT_TYPE COMMA expr COMMA expr [COMMA PLOT_MARK] [COMMA expr] optional_rparen

command_statement ::= simple_command | arguments_command
private simple_command ::= COMMAND_NO_PARENS [<<list expr>>] { pin=1 }
private arguments_command ::= COMMAND_WITH_PARENS LPAREN <<list expr>> optional_rparen { pin=1 }

/////////////////////////////////////// SIMPLE STATEMENTS ////////////////////////////////////////

////////////////////////////////////// COMPOUND STATEMENTS ///////////////////////////////////////
is_ds_statement ::= (IS | DS) LPAREN SIMPLE_VARIABLE COMMA expr optional_rparen NEWLINE statement_internal { pin=1 }

if_statement ::= IF expr NEWLINE if_body { methods=[getPresentation] }
private if_body ::= (then_block [else_block | END]) | statement_internal
then_block ::= THEN then_block_ { methods=[getPresentation] }
else_block ::= ELSE end_block_ optional_end { methods=[getPresentation] }

while_statement ::= WHILE expr while_body { methods=[getPresentation] pin=1 }
private while_body ::= end_block_ optional_end

repeat_statement ::= REPEAT expr repeat_body { methods=[getPresentation] pin=1 }
private repeat_body ::= end_block_ optional_end

for_statement ::= FOR LPAREN for_identifier COMMA expr COMMA expr [COMMA expr] optional_rparen for_body { methods=[getPresentation] pin=1 }
private for_body ::= end_block_ optional_end
for_identifier ::= SIMPLE_VARIABLE
{
    mixin="nl.petertillema.tibasic.psi.impl.TIBasicNamedElementImpl"
    implements="nl.petertillema.tibasic.psi.TIBasicNamedElement"
    methods=[getName setName getNameIdentifier]
}
////////////////////////////////////// COMPOUND STATEMENTS ///////////////////////////////////////
